---
layout: post
title: "linux下C++编译器G++的使用" 
date: 2016-09-18 11:25:07 +0800
categories: C++
tags: C++ g++ linux
---
* content
{:toc}

![](http://i.imgur.com/BdpX9tv.jpg)









实验室的课题以及平时程序代码的编写，在Windows环境下，基本上都是通过IDE来编写调试程序，但是在linux环境下通过`g++`编译器和`vim`编辑器来编写程序，在体验上更加`geek`，通过在linux系统下工作学习，真正的达到了心无旁骛，专心写代码，谨以此作个简单的记录。接下来的时间，将算法方面的学习转移到linux上，熟悉linux环境下`g++`编程和`gdb`调试以及了解`makefile`的编写。

## g++ ##

### 流程 ###

linux下的可执行文件并不像Windows系统以`.exe`文件后缀标志，只需要分配`x`(可执行)权限即可`sudo chmod u+x excutefile`

```cpp
源文件-->预处理-->编译-->汇编-->链接-->可执行文件

```

关于详细流程可参考：[C/C++程序编译流程（预处理->编译->汇编->链接）](http://www.cnblogs.com/Lynn-Zhang/p/5377024.html)


```cpp
#include <iostream>
#define MAX 100
int main()
{
 std::cout<<MAX<<std::endl; //output the max
 return 0;
}

```

**1.预处理,生成.i的文件[预处理器cpp]**

```cpp
g++ -E test.cpp > test.i 
```

通过执行上面的命令，输出预处理后的文件，如下面部分可以看到主要做宏的替换、注释的消除以及找到相关库文件。在该步骤不会进行语法错误检查。



```cpp
song@song-pc:~$ cat test.i |less

# 1 "test.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "test.cpp"
# 1 "/usr/include/c++/5/iostream" 1 3
# 36 "/usr/include/c++/5/iostream" 3       
# 37 "/usr/include/c++/5/iostream" 3
# 1 "/usr/include/x86_64-linux-gnu/c++/5/bits/c++config.h" 1 3
# 194 "/usr/include/x86_64-linux-gnu/c++/5/bits/c++config.h" 3
/////////////////////省略了部分内容//////////////////////////////
# 2 "test.cpp" 2
# 4 "test.cpp"
int main()
{
 std::cout<<100<<std::endl;
 return 0;
}
```



**2.将预处理的文件转换成汇编语言，生成文件.s[编译器egcs]**

```cpp
g++ -S test.cpp
```

**3.汇编变为目标代码，生成.O文件**

```cpp
g++ -C test.cpp
```
在该步骤进行词法和语法的检查，比如花括号不匹配，行末没有分号,关键字错误等。

**4.连接目标代码，生成可执行程序**

```cpp
g++ test.o -L F:\include\iostream
```

将`.o`文件与所需的库文件链接整合成可执行文件。



### 模块化程序 ###

上面讲述的是单个cpp文件，但是开发中采用的是模块化开发，需要多个源文件共同组成编译单元，最终形成可执行程序。

创建以下三个文件：

```cpp
-rw-rw-r--  1 song song  100 9月  18 16:34 hello.cpp
-rw-rw-r--  1 song song   32 9月  18 16:32 hello.h
-rw-rw-r--  1 song song   75 9月  18 16:36 main.cpp

```
各个源文件内容为：

**hello.h**

```cpp
song@song-pc:~/test$ cat hello.h
extern void print();
```

**hello.cpp**

```cpp
song@song-pc:~/test$ cat hello.cpp
#include <iostream>
using namespace std;
void print()
{
  cout<<"hello world"<<endl;
}
```


**main.cpp**


```cpp
song@song-pc:~/test$ cat main.cpp
#include "hello.h"
void print();

int main()
{
  print();
  return 0;
}
```

最后生成执行命令

```cpp
song@song-pc:~/test$ g++ hello.cpp main.cpp -o hello
```
当然以上命令也可以分拆为3步命令

```cpp
song@song-pc:~/test$ g++ -c hello.cpp -o hello.o
song@song-pc:~/test$ g++ -c main.cpp -o main.o
song@song-pc:~/test$ g++ hello.o main.o -o hello
```

## gdb ##

当程序编译完成，但是可能无法正常运行，或者是生成的结果不是需要的，这样的情况就需要对程序进行调试跟踪代码块的执行。`gdb`是`GNU`开发组织发布的一个强大的`UNIX/Linux`下的程序调试工具。主要有以下功能：

1. 启动程序，可以按照用户自定义的要求运行程序。
2. 可让被调试的程序在用户所指定的调试的断点处停住 (断点可以是条件表达式)。
3. 当程序停住时，可以检查此时程序中所发生的事。
4. 动态地改变程序的执行环境。

从功能上来看，gdb和一般的调试工具区别不大，可能习惯了图形化的调试工具暂时还不大习惯，但有时候，命令行的调试工具却有着图形化工具所不能完成的功能。­­­­­­­­­­­­­­­­­­­­­­­­­­­